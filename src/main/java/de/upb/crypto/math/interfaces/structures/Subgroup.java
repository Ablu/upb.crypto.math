package de.upb.crypto.math.interfaces.structures;

import de.upb.crypto.math.serialization.BigIntegerRepresentation;
import de.upb.crypto.math.serialization.ObjectRepresentation;
import de.upb.crypto.math.serialization.RepresentableRepresentation;
import de.upb.crypto.math.serialization.Representation;
import de.upb.crypto.math.structures.zn.Zn;

import java.math.BigInteger;
import java.util.Optional;

public class Subgroup implements Group {

    private Group parent;
    private GroupElement generator;
    private BigInteger size;

    public BigInteger getCofactor() {
        return parent.size().divide(size);
    }

    public Subgroup(Group parentGroup, GroupElement generator, BigInteger size) {
        if (!parentGroup.size().mod(size).equals(BigInteger.ZERO)) {
            throw new IllegalArgumentException("The cofactor has to divide the group order.");
        }

        this.parent = parentGroup;
        this.size = size;
        this.generator = generator;
    }

    public Subgroup(Representation repr) {
        ObjectRepresentation or = (ObjectRepresentation) repr;
        this.parent = (Group) ((RepresentableRepresentation) or.get("parent")).recreateRepresentable();
        this.generator = this.parent.getElement(or.get("generator"));
        this.size = ((BigIntegerRepresentation) or.get("size")).get();
    }


    @Override
    public GroupElement getGenerator() {
        return generator;
    }

    @Override
    public GroupElement getUniformlyRandomElement() throws UnsupportedOperationException {
        return this.getGenerator().pow((new Zn(size)).getUniformlyRandomElement());
    }

    public GroupElement project(GroupElement g) {
        return g.pow(getCofactor());
    }

    @Override
    public BigInteger size() throws UnsupportedOperationException {
        return parent.size().divide(getCofactor()
        );
    }

    @Override
    public GroupElement getElement(Representation repr) {
        return parent.getElement(repr);
    }

    @Override
    public Representation getRepresentation() {
        ObjectRepresentation r = new ObjectRepresentation();
        r.put("parent", new RepresentableRepresentation(parent));
        r.put("generator", generator.getRepresentation());
        r.put("size", new BigIntegerRepresentation(size));

        return r;
    }

    @Override
    public GroupElement getNeutralElement() {
        return parent.getNeutralElement();
    }

    @Override
    public String toString() {
        return "Subgroup of " + parent.toString() + " generated by " + generator.toString();
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((generator == null) ? 0 : generator.hashCode());
        result = prime * result + ((parent == null) ? 0 : parent.hashCode());
        result = prime * result + ((size == null) ? 0 : size.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Subgroup other = (Subgroup) obj;
        if (generator == null) {
            if (other.generator != null)
                return false;
        } else if (!generator.equals(other.generator))
            return false;
        if (parent == null) {
            if (other.parent != null)
                return false;
        } else if (!parent.equals(other.parent))
            return false;
        if (size == null) {
            if (other.size != null)
                return false;
        } else if (!size.equals(other.size))
            return false;
        return true;
    }

    @Override
    public Optional<Integer> getUniqueByteLength() {
        return parent.getUniqueByteLength();
    }

    @Override
    public int estimateCostOfInvert() {
        return parent.estimateCostOfInvert();
    }

    @Override
    public boolean isCommutative() {
        return parent.isCommutative();
    }
}
